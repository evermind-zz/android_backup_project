#!/bin/bash

curr_dir="$(dirname "$0")"
. "$curr_dir/functions.sh"
. "$curr_dir/lib/functions_installer.sh"

shopt -s expand_aliases
# FNC_RETURN_VAL has to be the number of args you want to shift
alias shiftArgs='for ((i=0;i < FNC_RETURN_VAL;i++)) ; do shift ; done ; let argCount-=$FNC_RETURN_VAL'

function printHelp() {
    local input="`egrep -o -- '--.*]].*;.*#.*' $0`"

    #### internal helper functions -- start
    function __determineLongest() {
        local option="$1"
        if [ ${#option} -gt $longest ] ; then
            longest=${#option}
        fi
    }

    function __printOptionAndText() {
        local option="$1"
        local text="$2"
        printf " %-${longest}s %s\n" "${option}" "${text}"
    }

    local reAllOptions='(--[a-zA-Z0-9-]*)\"\ *]][^#]*#\ *([^#]*)#(.*)'
    local reArgAndHelp='>>(.*)<<\ (.*)'
    function __processHelpOptions() {
        local input="$1"
        local methodPointer="$2"
        while [[ "$input" =~ $reAllOptions ]] ; do
            local option=${BASH_REMATCH[1]}
            local text=${BASH_REMATCH[2]}
            local remaining=${BASH_REMATCH[3]}

            # check if option has arg specified in $text
            if [[ "$text" =~ $reArgAndHelp ]] ; then
                arg=${BASH_REMATCH[1]}
                text=${BASH_REMATCH[2]}
                option+=" $arg"
            fi

            $methodPointer "$option" "$text"
            input="${remaining}"
        done
    }
    #### internal helper functions -- end

    # find longest option to get the output nice
    local longest=0
    __processHelpOptions "$input" "__determineLongest"
    let longest+=1 # more space(s)

    # print the help
    echo -e "Usage: ` basename $0` [OPTION]... [FILE(S)]...\n"
    __processHelpOptions "$input" "__printOptionAndText"
    exit 0
}

function checkIfDirExists() {
    if [ "a${1}b" == "ab" ] ; then
        eerror "[Error]: You have to specify a dir with $2"
        exit 1
    fi
    if ! test -e $1; then
        eerror "[Error]: the dir you specified does not exist:"
        eerror "\"$1\""
        exit 1
    fi
}

INSTALLER_NAME=""
DO_INSTALL=false
DO_LIST=false

declare -A splitApk2DimArray
declare -a splitApk2DimArrayCountCols
splitApk2DimArrayRowCount=0

REMOTE_TMP_BASE_PATH="/data/local/tmp"
REMOTE_TMP_APK_DIR="" # will be generated by createRemoteTmpApkDir()

function readApksIntoSpitApk2DimArray() {
    local isSplitApp=$1 ; shift
    local noOfShifts=0

    if [ "a${1}b" == "ab" ] || [[ ${1} =~ ^--[a-zA-Z] ]] ; then
        echo "[Error]: You have to specify files here"
        exit 1
    fi

    local noOfColumns=0
    while ([ "a${1}b" != "ab" ] && ! [[ ${1} =~ ^--[a-zA-Z] ]]) ; do
        let noOfShifts+=1
        splitApk2DimArray[$splitApk2DimArrayRowCount,$noOfColumns]="$1"
        let noOfColumns+=1
        shift

        if ! $isSplitApp ; then
            splitApk2DimArrayCountCols[$splitApk2DimArrayRowCount]=$noOfColumns
            let splitApk2DimArrayRowCount+=1
            noOfColumns=0
        fi
    done
    if $isSplitApp ; then
        splitApk2DimArrayCountCols[$splitApk2DimArrayRowCount]=$noOfColumns
        let splitApk2DimArrayRowCount+=1
    fi
    FNC_RETURN_VAL=$noOfShifts
}

function readApkFromDir() {
    local isSplit=$1
    local apkDir="$2"
    checkIfDirExists "$apkDir" "apks you want"
    if [ "a${apkDir}b" != "ab" ] ; then
        local apkFiles=(`find $apkDir -iname '*.apk'`)
        if [ ${#apkFiles[@]} -gt 0 ] ; then
            readApksIntoSpitApk2DimArray $isSplit ${apkFiles[@]}
        fi
    fi
}

argCount=${#@}
while [ $argCount -gt 0 ] ; do
    if [[ "$1" == "--install" ]]; then # install apk(s) you specified with --apk-*#
        shift; let argCount-=1
        DO_INSTALL=true
    elif [[ "$1" == "--list" ]]; then # list apk(s) you specified with --apk-*#
        shift; let argCount-=1
        DO_LIST=true
    elif [[ "$1" == "--apk-files" ]]; then # >>APK1 APK2 ...<< apk(s) that are complete app(s)#
        shift; let argCount-=1
        readApksIntoSpitApk2DimArray false $@
        shiftArgs
    elif [[ "$1" == "--apk-files-split" ]]; then # >>APK1 APK2 ...<< apk paths for a split app#
        shift; let argCount-=1
        readApksIntoSpitApk2DimArray true $@
        shiftArgs
    elif [[ "$1" == "--apk-dir" ]] ; then # >>DIR<< the directory with (none split) apk(s) for app(s)#
        shift; let argCount-=1
        readApkFromDir false "$1"
        shift; let argCount-=1
    elif [[ "$1" == "--apk-dir-split" ]] ; then # >>DIR<< the directory with (split) apks for single app#
        shift; let argCount-=1
        readApkFromDir true "$1"
        shift; let argCount-=1
    elif [[ "$1" == "--installer-name" ]] ; then #  >>NAME<< the installer signature to use: eg "com.android.vending"#
        shift; let argCount-=1
        INSTALLER_NAME=$1
        shift; let argCount-=1
    elif [[ "$1" == "--help" ]]; then # show this help#
        shift; let argCount-=1
        printHelp
    else
        echo "ERROR unknown parameter: $1"
        exit
    fi
done

function installApks() {
    local installer="$1" ; shift

    if [ "a${REMOTE_TMP_APK_DIR}b" == "ab" ] ; then
        REMOTE_TMP_APK_DIR="$(createRemoteTmpApkDir "$REMOTE_TMP_BASE_PATH")"
    fi

    pushApksToRemoteTmpDir "$REMOTE_TMP_APK_DIR" $@
    installSplitApks "$installer" "$REMOTE_TMP_APK_DIR"
    cleanTmpDirFromApks "$REMOTE_TMP_APK_DIR"
}

function installApp() {
    if $DO_LIST ; then
        #for x in ${@} ; do
        #    einfo $x
        #done
        einfo "apks_per_session=\"${@}\""
    else
        installApks "$INSTALLER_NAME" ${@}
    fi
}

########### script flow ###########
if $DO_INSTALL || $DO_LIST; then
    # install app(s)
    for ((row=0;row < splitApk2DimArrayRowCount;row++)) do
        apks=()
        for ((col=0;col < splitApk2DimArrayCountCols[row];col++)) do
            edebug $row $col ${splitApk2DimArray[$row,$col]}
            apks+=(${splitApk2DimArray[$row,$col]})
        done
        installApp ${apks[@]}
    done

    removeTmpApkDir "$REMOTE_TMP_APK_DIR"
fi
