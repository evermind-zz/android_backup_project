#!/bin/bash
# License; Apache-2
# Originally from Raphael Moll
# Tested/Fixed for Android O by marc_soft@merlins.org 2017/12
# improved / completly reworked to play nice with Android 9 / 10 by anddisa@gmail.com 2019/12

cat <<EOF
WARNING: restoring random system apps is quite likely to make things worse
unless you are copying between 2 identical devices.
You probably want to mv backupdir/app_{com.android,com.google}* /backup/location
This will cause this script not to try and restore system app data

EOF
#sleep 5

# variables could be set via commandline args
DATA_PATH="/data"
BACKUP_DIR=""
DO_SINGLE_APP=false
SINGLE_APP=""
DO_ONLY_MATCHING_APPS=false
MATCHING_APPS=""
DO_IT=true # for try run
DO_UPDATE_TOOLS=false
DO_LIST_APPS_ONLY=false
DO_PRECAUTION=true
DO_USE_CUSTOM_APP_DATA_DELETE=false

REMOTE_TMP_BASE_PATH="/data/local/tmp"
REMOTE_TMP_APK_DIR="" # will be generated by createRemoteTmpApkDir()
curr_dir="$(dirname "$0")"
. "$curr_dir/lib/functions_options.sh"

function displayHelp()
{
    echo
    echo "$0 is a script to restore apks, data, external data, keystores, permissions. For more information have a look at this help."
    echo
    for x in --backup-dir --data-path --debug --do-nothing --help --matching-apps --no-apk --no-data --no-ext-data --no-keystore --no-perms --only-apk --only-data --only-ext-data --only-keystore --only-perms --single-app --update-tools --list-apps-only --no-precaution --behaviour-delete-app-data; do
        str="$(optionHelp "$x" false)"
        printPretty "$x" "$str"
    done
    echo ""
    echo "some examples:"
    echo "=========="
    echo "# restore single app to device:"
    echo "bash restore_apps.sh --single-app \"org.videolan.vlc\""
    echo "=========="
    echo "# restore only apks to device:"
    echo "bash  restore_apps.sh --backup-dir myBackupDir --no-keystore --no-data --no-ext-data --no-perms"
}

argCount=${#@}
while [ $argCount -gt 0 ] ; do

    if [[ "$1" == "--backup-dir" ]]; then
        shift; let argCount-=1
        BACKUP_DIR="$1"
        shift; let argCount-=1
    elif [[ "$1" == "--help" ]]; then
        shift; let argCount-=1
        displayHelp
        exit 0
    elif [[ "$1" == "--debug" ]]; then
        shift; let argCount-=1
        DEBUG=true
    elif [[ "$1" == "--do-nothing" ]]; then
        shift; let argCount-=1
        DO_IT=false
    elif [[ "$1" == "--no-apk" ]]; then
        shift; let argCount-=1
        DO_ACTION_APK=false
    elif [[ "$1" == "--no-data" ]]; then
        shift; let argCount-=1
        DO_ACTION_DATA=false
    elif [[ "$1" == "--no-ext-data" ]]; then
        shift; let argCount-=1
        DO_ACTION_EXT_DATA=false
    elif [[ "$1" == "--no-keystore" ]]; then
        shift; let argCount-=1
        DO_ACTION_KEYSTORE=false
    elif [[ "$1" == "--no-perms" ]]; then
        shift; let argCount-=1
        DO_ACTION_PERMISSIONS=false
    elif [[ "$1" == "--only-apk" ]]; then
        shift; let argCount-=1
        resetActions
        DO_ACTION_APK=true
    elif [[ "$1" == "--only-data" ]]; then
        shift; let argCount-=1
        resetActions
        DO_ACTION_DATA=true
    elif [[ "$1" == "--only-ext-data" ]]; then
        shift; let argCount-=1
        resetActions
        DO_ACTION_EXT_DATA=true
    elif [[ "$1" == "--only-keystore" ]]; then
        shift; let argCount-=1
        resetActions
        DO_ACTION_KEYSTORE=true
    elif [[ "$1" == "--only-perms" ]]; then
        shift; let argCount-=1
        resetActions
        DO_ACTION_PERMISSIONS=true
    elif [[ "$1" == "--behaviour-delete-app-data" ]]; then
        shift; let argCount-=1
        DO_USE_CUSTOM_APP_DATA_DELETE=true
    elif [[ "$1" == "--update-tools" ]]; then
        shift; let argCount-=1
        DO_UPDATE_TOOLS=true
    elif [[ "$1" == "--data-path" ]]; then
        #CUSTOM_BUSYBOX_TARGET_BIN=/tmp/busybox
        shift; let argCount-=1
        DATA_PATH=$1
        shift; let argCount-=1
    elif [[ "$1" == "--list-apps-only" ]]; then
        shift; let argCount-=1
        DO_LIST_APPS_ONLY=true
    elif [[ "$1" == "--single-app" ]]; then
        shift; let argCount-=1
        if [ "a${1}b" == "ab" ] ; then
            echo "ERROR: You have to specify a package signature for --single-app"
            echo "-->eg. --single-app com.starfinanz.mobile.android.dkbpushtan"
            exit 1
        fi
        DO_SINGLE_APP=true
        SINGLE_APP=$1
        shift; let argCount-=1

    elif [[ "$1" == "--matching-apps" ]]; then
        DO_ONLY_MATCHING_APPS=true
        shift; let argCount-=1
        if [ "a${1}b" == "ab" ] ; then
            echo "ERROR: You have to specify a package signature(s) for --matching-apps"
            echo "-->eg. --matching-apps \"com.starfinanz.mobile.android.dkbpushtan|com.github.bravenewpipe\""
            exit 1
        fi
        MATCHING_APPS=$1
        shift; let argCount-=1
    elif [[ "$1" == "--no-precaution" ]]; then
        shift; let argCount-=1
        DO_PRECAUTION=false

    else
        echo "ERROR unknown parameter: $1"
        exit
    fi
done

if [[ ! -d "$BACKUP_DIR" ]] || [ "a${BACKUP_DIR}b" == "ab" ]; then
	echo "Usage: $0 --backup-dir <data-dir>"
	echo "Must be created with ./backup_apps.sh"
	exit 2
fi

. "$curr_dir/functions.sh"
. "$curr_dir/lib/functions_installer.sh"
. "$curr_dir/lib/functions_restore.sh"

set -e   # fail early
function readUserAnswerAndExitIfNotYes() {
    read answer
    if [ "a${answer}b" != "aYESb" ] ; then
        einfo "You did well and double check everything now!!!"
        exit 0
    fi
}

if $DO_PRECAUTION ; then
    einfo "###############################################################"
    einfo "# WARNING: Are you sure that your PC is connected to the correct device?"
    einfo "# Is \"$BACKUP_DIR\" the correct backup you want to restore from?"
    einfo "#"
    einfo "# Existing apps/data could be overwritten. Please doublecheck now!"
    einfo "# Type YES to continue. (you can ignore this warning with: --no-precaution"
    einfo "###############################################################"
    readUserAnswerAndExitIfNotYes
fi

OLDIFS="$IFS"

checkPrerequisites

if $DO_IT ; then

    if ! $DO_LIST_APPS_ONLY ; then
        updateBusybox "$DO_UPDATE_TOOLS"
        updateTarBinary "$DO_UPDATE_TOOLS"

        lookForAdbDevice

        checkRootType

        pushBusybox
        pushTarBinary
    fi
fi

cd "$BACKUP_DIR"

APPS=$(find -maxdepth 1 -type d -printf "%P\n" | egrep '([a-z0-9].){2,}')

function isAppThereOrFail() {
    local apps="$1"
    local appToBeFound="$2"
    local doNotFailButReturnNegative=${3:-false}
    local isAppInBackup="`echo "${apps}" | grep "^${appToBeFound}$"`"
    if [ ${#isAppInBackup} -eq 0 ] ; then
        einfo "There is no app \"$appToBeFound\" to restore"
        if $doNotFailButReturnNegative ; then
            return 1
        else
            exit 1
        fi
    fi
    FNC_RETURN2="${isAppInBackup}"
    return 0
}

function matchApp() {
    if $DO_ONLY_MATCHING_APPS ; then
        NEW_APPS=()
        local areAppsMissing=false

        for x in `echo $MATCHING_APPS | sed -e 's@|@ @g'` ; do
            if ! isAppThereOrFail "${APPS}" "${x}" true ; then
                areAppsMissing=true
            else
                NEW_APPS+=($FNC_RETURN2)
            fi
        done

        if $areAppsMissing ; then
            exit 1
        fi

        FNC_RETURN="${NEW_APPS[*]}"
	einfo "## Restoring matching app(s) in $BACKUP_DIR: "${FNC_RETURN}""
    elif $DO_SINGLE_APP ; then
        isAppThereOrFail "${APPS}" "${SINGLE_APP}"
        FNC_RETURN="$FNC_RETURN2"
	einfo "## Restoring single app in $BACKUP_DIR: "${FNC_RETURN}""
    else
        FNC_RETURN="`echo "$APPS"`"
	einfo "## Restoring all apps in $BACKUP_DIR: "${FNC_RETURN}""
    fi
}

function restoreKeystore() {
    local keystoreTmpDir="$1"
    local oldUid="$2"
    local newUid="$3"
    local keystorePath="$4"

    $AS "$BUSYBOX find "$keystoreTmpDir" | grep $oldUid"

    for x in `$AS "$BUSYBOX find "$keystoreTmpDir" | grep $oldUid"` ; do
        local targetFile="${keystorePath}/`basename ${x/$oldUid/$newUid}`"
        $AS "$BUSYBOX mv "$x" "$targetFile""
        # fix selinux context
        $AS "restorecon -FRv "$targetFile""

    done
}

function getPerms() {
    local permsXml="$1"
    cat "$permsXml" | decryptIfNeeded | xmlstarlet sel -T -t -m "//pkg/item"  -v "@name" -o "|" -v "@granted" -n
}

function getMetaAttr() {
    local attr="$1"
    local metaXml="$2"
    cat "$metaXml" | decryptIfNeeded | xmlstarlet sel -T -t -m "//package"  -v "@$attr"  -n
}

function getPipeSeparatedField() {
    local pos="$1"
    local input="$2"
    echo "$input" | awk -F'|' "{print \$$1}"
}

function generatePmGrantRevokeCmd() {
    local dataSet="$1"
    local pkgSign="$2"
    local isGranted=$(getPipeSeparatedField 2 "$dataSet")
    local permission=$(getPipeSeparatedField 1 "$dataSet")
    local actionString="revoke"

    if [ "a${isGranted}b" == "atrueb" ] ; then
        actionString="grant"
    fi

    echo "pm $actionString $pkgSign $permission"
}

function getSymlinkTarget()
{
    local appInstalledBaseDir="$1"
    local target_arch="$(determineArch)"
    local symlink_target="$appInstalledBaseDir/lib/$target_arch"

    if $AS test -d "$symlink_target" ; then
        echo "$symlink_target"
    else
        local fallback_arch="$(fallbackArch "$target_arch")"
        symlink_target="$appInstalledBaseDir/lib/$fallback_arch"
        if $AS test -d "$symlink_target" ; then
            echo "$symlink_target"
        fi
    fi
}

function restoreExtraData()
{
    extraDataPackage="$(getExtraDataFileName "${appPackage}")"
    if $DO_ACTION_EXT_DATA ; then
        if test -e "$extraDataPackage" ; then
            einfo "[$appSign]: restoring app extra data"

            extraDataPath="$DATA_PATH/media/0/Android/data/${dataDir}"
            fix_extra_perms_script=$appDataDir/${dataDir}_fix_extra_permissions_0234fo3.sh

            if $DO_IT ; then
                $AS "$BUSYBOX mkdir -p "$extraDataPath""
                cat "$extraDataPackage" | decryptIfNeeded | decompressor | pv -trab | $AS "$TAR -xpf - -C "$extraDataPath""
IFS="
"
                createExtDataPermUpdateScript "$extraDataPath" "$oldGid" "$newGid" | grep -v "$fix_extra_perms_script" | eval $AS "$BUSYBOX tee "$fix_extra_perms_script""
                IFS="$OLDIFS"
                einfo "[$appSign]: run generated script to fix ownership of app extra data"
                fail_on_error $AS "$BUSYBOX chown -F "$fix_extra_perms_script""
                fail_on_error $AS "$BUSYBOX rm "$fix_extra_perms_script""
            fi
        else
            einfo "[$appSign]: NOT restoring app extra data -- no backup file"
        fi
    else
        einfo "[$appSign]: SKIP restoring app extra data -- as requested via commandline"
    fi
}

function restoreKeystores()
{
    keystorePath="$DATA_PATH/misc/keystore/user_0"
    keystorePackage="$(getKeystoreFileName "${appPackage}")"
    if $DO_ACTION_KEYSTORE ; then
        if test -e "$keystorePackage" ; then
            einfo "[$appSign]: restoring keystores"

            if $DO_IT ; then
                keystoreTmpDir="`$AS $BUSYBOX mktemp -d -p $REMOTE_TMP_BASE_PATH`"
                cat "$keystorePackage" | decryptIfNeeded | decompressor | pv -trab | $AS "$TAR -xpf - -C "$keystoreTmpDir""
                restoreKeystore "$keystoreTmpDir" "$oldUid" "$newUid" "$keystorePath"
                $AS "$BUSYBOX rmdir "$keystoreTmpDir""
            fi
        else
            einfo "[$appSign]: NOT restoring keystores -- no backup file"
        fi
    else
        einfo "[$appSign]: SKIP restoring keystores -- as requested via commandline"
    fi
}

function checkForEncryptedBackup()
{
    local appSign="$1"
    if [ $(find $appSign/ -name '*.enc' | wc -l) -gt 0 ] ; then
        G_DO_ENCRYPT_DECRYPT=true
        checkIfPwPresent
    fi
}

function restorePermissions()
{
    local appSign="$1"
    local permsPackage="$2"
    local whatPerms="$3"

    if test -e "$permsPackage" ; then
        einfo "[$appSign]: restoring previously permissions of $whatPerms"

        local permissions=$(getPerms "$permsPackage")
        for x in ${permissions[@]} ; do
            cmd="$(generatePmGrantRevokeCmd "$x" "$appSign")"
            $DO_IT && ($AS "$cmd" && echo "success perms: $cmd" || echo "error perms: $cmd")
        done
    else
        einfo "[$appSign]: NOT restoring previously $whatPerms permissions -- no backup file"
    fi
}

function installApks() {
    local installer="$1" ; shift
    local noOfApks="${#@}"

    if [ "a${REMOTE_TMP_APK_DIR}b" == "ab" ] ; then
        REMOTE_TMP_APK_DIR="$(createRemoteTmpApkDir "$REMOTE_TMP_BASE_PATH")"
    fi

    pushApksToRemoteTmpDir "$REMOTE_TMP_APK_DIR" $@

    #if [ "$noOfApks" -eq 1 ] ; then
    #    local remoteApkFile
    #    $A shell pm install $(doWeNeedInstallerSwitch "$installer") "$installer" -t -r "$1"
    #elif [ "$noOfApks" -gt 1 ] ; then
        installSplitApks "$installer" "$REMOTE_TMP_APK_DIR"
    #fi
    cleanTmpDirFromApks "$REMOTE_TMP_APK_DIR"
}

showGlobalBackupInfo

einfo "## Installing apps"

matchApp
APPS="$FNC_RETURN"
edebug "APPS=$APPS"
for appSign in $APPS; do
	edebug "appSign=$appSign"
        checkForEncryptedBackup "${appSign}"

        appPackage="$(getAppFileName "${appSign}")"
        metaPackage="$(getMetaFileName "${appPackage}")"

        installer=""
        # read original installer app from $metaPackage
        if test -e "$metaPackage" ; then
            installer=$(getMetaAttr "installer" "$metaPackage")
        fi

    if $DO_LIST_APPS_ONLY ; then
        it=$(getMetaAttr "it" "$metaPackage")
        ut=$(getMetaAttr "ut" "$metaPackage")
        einfo "APP|firstInstallTime=$(getDateForMilliSecondsSince1970 "$it")|lastUpdateTime=$(getDateForMilliSecondsSince1970 "$ut")|$appSign"
        continue
    fi

        #####################
        # restore app
        #####################

        if $DO_ACTION_APK ; then
            if test -e "$appPackage" ; then

	        APP=`cat "$appPackage" | decryptIfNeeded | tar xvzf - -C /tmp/ --wildcards "*.apk" | sed 's/\.\///'`
                einfo "[$appSign]: restoring apk(s): $APP "
	        edebug "[$appSign]: appPackage=$appPackage"
	        edebug "[$appSign]: Installing: APP=$APP"
	        if $DO_IT ; then
                    pushd /tmp &> /dev/null
	            #error=`$A install-multiple -r -t ${APP}`
	            #eerror "[$appSign]: error=$error"
                    installApks "$installer" ${APP}

	            rm ${APP}
	            popd &> /dev/null
                fi
            else
                einfo "[$appSign]: NOT restoring apk(s) -- no backup file"
            fi
        else
            einfo "[$appSign]: SKIP restoring apk(s) -- as requested via commandline"
        fi

	$DO_IT && allApps=`$A shell cmd package list packages -f`
	appInstalledBaseApk=$(echo "$allApps" | grep "$appSign$" | awk -F':' '{print $2}' | egrep -io '.*\.apk=' | sed 's@=$@@g')

        if $DO_IT && [ ${#appInstalledBaseApk} -eq 0 ] ; then
            eerror "[$appSign]: package not installed no restoring of app data, etc. possible. Please install suitable apk first"
            exit 1
        fi
	appInstalledBaseDir=$(dirname "$appInstalledBaseApk")

	#edebug "allApps=$allApps"

	dataDir=$appSign
	edebug "[$appSign]: dataDir=$dataDir"

        if $DO_IT ; then
            $AS am stop-app $appSign || $AS am force-stop $appSign
           sleep 1
        fi

        #####################
        # restore app data
        #####################
	edebug "[$appSign]: Attempting to restore data for $APP"
        appDataDir="$DATA_PATH/data/$dataDir"
        #newUid=$(getUserIdOfFile "$appDataDir")
        #newGid=$(getGroupIdOfFile "$appDataDir")
        if $DO_IT ; then
            newUid=$(getUserIdFromDumpsys "$appSign")
            noEmptyValueOrFail "$newUid" "\$newUid for the apk $appSign could not be read"
        fi

        newGid=$newUid

	if $DO_IT && [[ -z $newUid ]]; then
	    eerror "[$appSign]: Error: $APP still not installed"
	    exit 2
	fi

	einfo2 "[$appSign]: app user id is $newUid"

        ####
        # restore data
	dataPackage="$(getDataFileName "${appPackage}")"
        if $DO_ACTION_DATA ; then
            if test -e "$dataPackage" ; then
                if $DO_IT ; then
                    if $DO_USE_CUSTOM_APP_DATA_DELETE ; then
                        if [ "a${appDataDir}b" != "ab" ] && [ "a${appDataDir}b" != "a/b" ] &! [[ ${appDataDir} =~ \* ]] \
                            && [[ $appDataDir =~  /data/data/.* ]] && doesDirExists "$appDataDir" ; then
                            einfo "[$appSign]: DELETE old app data directory \"$appDataDir\". Type YES to do so!"
                            readUserAnswerAndExitIfNotYes
                            $AS "$BUSYBOX rm -rf "$appDataDir""
                            $AS "$BUSYBOX mkdir -p "$appDataDir""
                        fi

                    else
	                $AS "pm clear $appSign"
	                sleep 1
                    fi
                fi
                einfo "[$appSign]: restoring app data"
	        $DO_IT && cat "$dataPackage" | decryptIfNeeded | decompressor | pv -trab | $AS "$TAR -xpf - -C $appDataDir"

                ####
                # fix lib symlink
                symlink="$appDataDir/lib"
                # test -L if there is a link and ! test -e if symlink is broken
                if $DO_IT && $AS test -L "$symlink" && ! $AS test -e "$symlink" ; then
                    originalSymlinkDate="$($AS "$BUSYBOX stat -c '%y' "$symlink"" | awk '{printf "%s %s\n", $1, $2}' | sed -e 's@\.[0-9]*$@@g' -e 's@ @\\ @g')"
                    $AS rm "$symlink"
                    symlink_target="$(getSymlinkTarget "$appInstalledBaseDir")"
                    if [ "a${symlink_target}b" != "ab" ] ; then
                        $AS "ln -s "$symlink_target" "$symlink""
                    fi
                    if $AS test -L "$symlink" ; then # restore date if symlink created
                        $AS "$BUSYBOX touch -ht \"$originalSymlinkDate\" "$symlink""
                    fi
                fi

                ####
                # restore app data ownership
                if $DO_IT ; then
                    oldUid=$(getUserIdOfFile "$appDataDir")
                    oldGid=$(getGroupIdOfFile "$appDataDir")
                    fix_perms_script=$appDataDir/${dataDir}_fix_permissions_0234fo3.sh
IFS="
"
                    createDataPermUpdateScript "$appDataDir" "$oldGid" "$newGid" "$oldUid" "$newUid" | grep -v "$fix_perms_script" | eval $AS "$BUSYBOX tee "$fix_perms_script""
                    IFS="$OLDIFS"
                    einfo "[$appSign]: run generated script to fix ownership of app data"
                    fail_on_error $AS "$BUSYBOX chown -F "$fix_perms_script""
                    fail_on_error $AS "$BUSYBOX rm "$fix_perms_script""

                    # fix selinux context
                    $AS "restorecon -FRDv "$appDataDir""
                fi
            else
                einfo "[$appSign]: NOT restoring app data -- no backup file"
            fi
        else
            einfo "[$appSign]: SKIP restoring app data -- as requested via commandline"
        fi

        #####################
        # in case no action data to be restored we still need need to know the oldGid
        # to properly restore the extra data / keystore data
        #####################
        IS_OLDUID_OLDGID_PRESENT=true
        if ! $DO_ACTION_DATA ; then
            if test -e "$metaPackage" ; then
                oldGid=$(getMetaAttr "userId" "$metaPackage")
                oldUid=$oldGid
            else
                IS_OLDUID_OLDGID_PRESENT=false
            fi
        fi

        #####################
        # restore app extra data
        #####################
        if $IS_OLDUID_OLDGID_PRESENT ; then
            restoreExtraData
        else
            einfo "[$appSign]: IMPOSSIBLE restoring app extra data -- as oldUid/oldGid not found in $metaPackage"
        fi

        #####################
        # restore keystore(s)
        #####################
        if $IS_OLDUID_OLDGID_PRESENT ; then
            restoreKeystores
        else
            einfo "[$appSign]: IMPOSSIBLE restoring keystores -- as oldUid/oldGid not found in $metaPackage"
        fi

        #####################
        # restore previously permissions"
        #####################
        if $DO_ACTION_PERMISSIONS ; then
            permsPackage=$(getPermFileName "${appPackage}")
            restorePermissions "$appSign" "$permsPackage" "app"

            permsSharedUserPackage=$(getPermSharedUserFileName "${appPackage}")
            restorePermissions "$appSign" "$permsSharedUserPackage" "shared user"
        else
            einfo "[$appSign]: SKIP restoring previously permissions -- as requested via commandline"
        fi
done
if ! $DO_LIST_APPS_ONLY ; then
    if $DO_IT ; then
        cleanup
        removeTmpApkDir "$REMOTE_TMP_APK_DIR"
    fi
fi

